use crate::explainer::extension::{parse_extension, Extension};
use crate::{explainer::extension::Field, plugin::Plugin};
use gosyn::ast::Expression::TypeStruct;
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Default, Debug)]
pub struct Validate {
    pub validate_suffix: String,
}

impl Validate {
    pub fn new() -> Validate {
        Validate::default()
    }
}

impl Plugin for Validate {
    fn name(&self) -> &'static str {
        "Validate"
    }

    fn header(&self, package_name: &str, path: &PathBuf) -> String {
        let file_stem = path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap()
            .replace(".", "_")
            .replace("-", "_");
        let mut header = String::new();
        header.push_str("// Code generated by craft; DO NOT EDIT.\n\n");
        header.push_str(&format!("package {}\n\n", package_name));
        header.push_str("import (\n");
        header.push_str("\t\"context\"\n");
        header.push_str("\t\"errors\"\n");
        header.push_str("\t\"github.com/go-playground/validator/v10\"\n");
        header.push_str("\t\"git.5th.im/lb-public/gear/util/metautil\"\n");
        header.push_str(")\n\n");
        header.push_str(&format!(
            "var validate_{} = validator.New(validator.WithRequiredStructEnabled())\n\n",
            file_stem,
        ));
        header
    }

    fn build(&self, ts: gosyn::ast::TypeSpec, _: Vec<Field>, path: &PathBuf) -> String {
        let ss = match ts.typ {
            TypeStruct(s) => s,
            _ => panic!("not support type"),
        };

        let struct_type_name = ts.name.name;
        let file_stem = path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap()
            .replace(".", "_")
            .replace("-", "_");

        let mut i18n_content = String::new();

        let mut validate_content = String::new();
        validate_content.push_str(&format!(
            "func ({} *{}) Validate(ctx context.Context) error {{\n",
            &struct_type_name[..1].to_lowercase(),
            struct_type_name
        ));

        ss.fields.iter().for_each(|f| {
            let comments = f
                .comments
                .iter()
                .map(|s| s.text.clone())
                .collect::<Vec<String>>()
                .join(" ");

            let exs = parse_extension(comments);
            let exs_map: HashMap<String, Extension> =
                exs.into_iter().map(|e| (e.name.clone(), e)).collect();

            if let Some(i18n_ex) = exs_map.get("i18n") {
                let i18n_ex_args = i18n_ex.args.as_ref().unwrap();

                i18n_content.push_str(&format!(
                    "type {}_{}Error struct{{}}\n\n",
                    struct_type_name, f.name[0].name
                ));

                i18n_content.push_str(&format!(
                    "func ({}_{}Error) Trans(ctx context.Context) error {{\n",
                    struct_type_name, f.name[0].name
                ));

                i18n_content.push_str("\tswitch metautil.Language(ctx) {\n");

                for arg in i18n_ex_args.iter() {
                    i18n_content.push_str(&format!("\tcase \"{}\":\n", arg.name));
                    i18n_content.push_str(&format!("\t\treturn errors.New(\"{}\")\n", arg.value));
                }

                i18n_content.push_str("\tdefault:\n");
                i18n_content.push_str(&format!(
                    "\t\treturn errors.New(\"{}\")\n",
                    i18n_ex_args.get(0).unwrap().value
                ));

                i18n_content.push_str("\t}\n");
                i18n_content.push_str("}\n\n");
            }

            if let Some(sub_validate) = exs_map.get(self.name()) {
                let mut var = String::new();
                let sub_validate_args = sub_validate.args.as_ref().unwrap();
                for (index, arg) in sub_validate_args.iter().enumerate() {
                    if index > 0 && index <= sub_validate_args.len() - 1 {
                        var.push(',');
                    }

                    if arg.value.len() != 0 {
                        var.push_str(&format!("{}={}", arg.name, arg.value));
                    } else {
                        var.push_str(&format!("{}", arg.name));
                    }
                }

                validate_content.push_str(&format!(
                    "\tif err := validate_{}.Var({}.{},\"{}\"); err != nil {{\n",
                    file_stem,
                    &struct_type_name[..1].to_lowercase(),
                    f.name[0].name,
                    var
                ));

                if exs_map.contains_key("i18n") {
                    validate_content.push_str(&format!(
                        "\t\treturn {}_{}Error.Trans(struct{{}}{{}},ctx)\n",
                        struct_type_name, f.name[0].name
                    ));
                } else {
                    validate_content.push_str("\t\treturn err\n");
                }

                validate_content.push_str("\t}\n\n");
            }
        });
        validate_content.push_str("\n\treturn nil\n}\n\n");

        i18n_content + &validate_content
    }
}
